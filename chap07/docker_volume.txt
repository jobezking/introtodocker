Docker volumes: preferred mechanism for persisting data generated by and used by Docker containers. Containers can create, 
update, and delete ﬁles, those changes are lost when the container is removed and all changes are isolated to that container.

1. Data Persistence: Volumes allow you to persist data even when containers are stopped or removed.
2. Data Sharing: Volumes can be shared and reused among multiple containers.
3. Performance: Volumes are stored on the host ﬁlesystem, which generally provides better I/O performance, especially for databases.
4. Data Management: Volumes make it easier to backup, restore, and migrate data.
5. Decoupling: Volumes decouple the conﬁguration of the Docker host from the container runtime.

Named volumes: recommended way to persist data in Docker. Explicitly given a name.

docker volume create my_volume  - create a named volume.
docker run -d --name devtest -v my_volume:/app nginx:latest

More practical example:
docker volume create --driver local \
  --opt type=none \
  --opt device=/media/data/kidney \
  --opt o=bind \
  kidney_data

docker run -d \
  --name elasticnet_app \
  -v kidney_data:/app/data \
  your_elasticnet_image

Anonymous volumes: automatically created by Docker and given random name. Used for temp data that lasts runtime of container.
docker run -d --name devtest -v /app nginx:latest

Bind mount: maps specific path of host machine to path in container (dev environment use only)
docker run -d --name devtest -v /media:app nginx latest

docker volume ls - list all volumes
docker volume inspect my_volume - get detailed info about volumes
docker volume rm my_volume - remove volume
docker volume prune - remove all unused volumes

Back up a volume:

docker run --rm -v my_volume:/source -v /path/on/host:/backup
ubuntu tar cvf /backup/backup.tar /source

Restore from backup:

docker run --rm -v my_volume:/target -v /path/on/host:/backup
ubuntu tar xvf /backup/backup.tar -C /target --strip 1

Volume Drivers: allows you to store volumes on local, remote or cloud hosts. local, nfs, AWS EBS, Azure File Storage
docker volume create --driver <driver_name> my_volume  i.e. docker volume create --driver local my_volume


Best Practices for Using Docker Volumes
1. Use named volumes: They're easier to manage and track than anonymous volumes.
2. Don't use bind mounts in production: They're less portable and can pose security risks.
3. Use volumes for databases: Databases require persistent
storage and beneﬁt from the performance of volumes.
4. Be cautious with permissions: Ensure the processes in your containers have the necessary permissions to read/write to volumes.
5. Clean up unused volumes: Regularly use docker volume prune to remove unused volumes and free up space.
6. Use volume labels: Labels can help you organize and manage your volumes.
docker volume create --label project=myapp my_volume
7. Consider using Docker Compose: Docker Compose makes it easier to manage volumes across multiple containers.

Advanced
Read-only -  docker run -d --name devtest -v my_volume:/app:ro nginx:latest
tmpfs mounts - docker run -d --name tmptest --tmpfs /app nginx:latest

Sharing volumes between containers
docker run -d --name container1 -v my_volume:/app nginx:latest
docker run -d --name container2 -v my_volume:/app nginx:latest

Volume Plugins: third party. 
docker plugin install <plugin_name>
docker volume create -d <plugin_name> my_volume

Troubleshooting Volume Issues
1. Volume not persisting data: Ensure you're using the correct
volume name and mount path.
2. Permission issues: Check the permissions of the mounted
directory both on the host and in the container.
3. Volume not removing: Make sure no containers are using the
volume before trying to remove it.
4. Performance issues: If you're experiencing slow I/O, consider
using a volume driver optimized for your use case.